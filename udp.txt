Краткое содержание:

Полезные штуки
Стек протоколов
Протокол Ethernet
ARP
IP
ICMP
UDP
Пишем приложение
Заключение

Что пригодится

При написании сетевых приложений для МК накосячить просто, а найти баг — не всегда. Так что, есть смысл для отладки использовать различные прикольные штуки, отладку общегчающие:

JTAG-адаптер для AVR'ок — поможет заглянуть в память и регистры МК, потрейсить прошивку. Поддерживается AVR Studio 4. Жутко тормозной, но найти многие баги с ним всё же намного быстрее, чем без него.
Wireshark — хороший кроссплатформенный сниффер. Покажет данные, передаваемые через сетевой адаптер компа. Умеет анализировать протоколы. Покажет в каком месте пакета что-то не так (битая чексумма, неверная длина пакета, etc.). Настраивается методом научного тыка)
netcat — удобная утилитка, которая поможет отправлять и принимать данные по сети. Под Windows можно взять нативную сборку, либо установить из cygwin'а.

Стек протоколов

Вот так будет выглядеть стек протоколов, который мы реализуем:

Стек протоколов

При прохождении пакета вниз по стеку, к нему прикрепляются заголовки протоколов. Например, вот так будет выглядеть UDP-пакет при передаче по сети Ethernet.

Пример пакета

В соответствии с моделью OSI, уровни должны быть изолированы друг от друга. Но у нас будет не совсем так, все протоколы будут работать с одним и тем же пакетом, но обращаться к своим заголовкам. Что позволит сэкономить память и такты микроконтроллера. Для такого простого стека это вполне нормально.

Неприятная особенность IP-стека — все поля пакетов всех протоколов закодированы в этом чудовищном атавизме, big endian'е. Придётся перекодировать в нормальный формат и обратно. Для этого пригодятся макросы:

// Перекодирование word'а
#define htons(a)            ((((a)>>8)&0xff)|(((a)<<8)&0xff00))
#define ntohs(a)            htons(a)

// Перекодирование dword'а
#define htonl(a)            ( (((a)>>24)&0xff) | (((a)>>8)&0xff00) |\
                                (((a)<<8)&0xff0000) | (((a)<<24)&0xff000000) )
#define ntohl(a)            htonl(a)


Для работы стека, устройству нужно задать MAC-адрес и IP-адрес.

// Макрос для IP-адреса
#define inet_addr(a,b,c,d)    ( ((uint32_t)a) | ((uint32_t)b << 8) |\
                                ((uint32_t)c << 16) | ((uint32_t)d << 24) )

// MAC-адрес
uint8_t mac_addr[6] = {0x00,0x13,0x37,0x01,0x23,0x45};

// IP-адрес
uint32_t ip_addr = inet_addr(192,168,0,222);



Ethernet

Вот формат Ethernet-фрейма:

Ethernet-фрейм

Контрольная сумма рассчитывается и проверяется ENC28J60, так что для нас остяются видимы только 4 поля:

Адрес получателя. Тут может находиться конкретный MAC-адрес, широковещательный адрес ff:ff:ff:ff:ff:ff или Multicast-адрес. В Multicast-адресе установлен бит 40 (01:00:00:00:00:00). Обрати на это внимание. Если ты установишь своему девайсу адрес, например, 01:23:45:67:89:ab, получишь кучу проблем, источник которых вовсе не очевиден. Когда будешь придумывать MAC-адрес, лучше вообще обнули старший байт.
Адрес отправителя. Тут MAC-адрес, с которого отправлен фрейм.
По стандарту, здесь может находиться длина поля данных фрейма (без выравнивания), либо идентификатор протокола. Если бит 8 (0x0800) установлен, поле идентифицирует протокол. В случае протоколов IP-стека (IP, ARP, etc.), здесь находится именно идентификатор протокола и ничего другого.
Поле данных. Здесь будет полезная нагрузка, например, IP-пакет. В нормальном фрейме данных должно быть от 60 до 1500 байт. Если реальных данных меньше, поле выравнивается нулями до 60 байт.

Вот пример работы с Ethernet-фреймом:

#define ETH_TYPE_ARP        htons(0x0806)
#define ETH_TYPE_IP            htons(0x0800)

// Ethernet-фрейм
typedef struct eth_frame {
    uint8_t to_addr[6]; // адрес получателя
    uint8_t from_addr[6]; // адрес отправителя
    uint16_t type; // протокол
    uint8_t data[];
} eth_frame_t;

// Отправка ответа на Ethernet-фрейм
//  (подходит для серверного приложения -
//  получили запрос, обменяли местами адрес отправителя и получателя,
//  отправили назад)
void eth_reply(eth_frame_t *frame, uint16_t len)
{
    memcpy(frame->to_addr, frame->from_addr, 6);
    memcpy(frame->from_addr, mac_addr, 6);
    enc28j60_send_packet((void*)frame, len + 
        sizeof(eth_frame_t));
}

// Обработчик получаемых Ethernet-фреймов
void eth_filter(eth_frame_t *frame, uint16_t len)
{
    // Проверяем длину фрейма
    // Проверять адрес получателя не будем,
    //  положимся на фильтр пакетов ENC28J60
    if(len >= sizeof(eth_frame_t))
    {
        switch(frame->type)
        {
        // Получен ARP-пакет, вызываем обработчик ARP-пакетов
        case ETH_TYPE_ARP:
            arp_filter(frame, len - sizeof(eth_frame_t));
            break;
        
        // Получен IP-пакет, вызываем обработчик IP-пакетов
        case ETH_TYPE_IP:
            ip_filter(frame, len - sizeof(eth_frame_t));
            break;
        }
    }
}


ARP

ARP (Address Resolution Protocol) — вспомогательный протокол, позволяющий получить MAC-адрес узла по IP-адресу.

Узел, желающий получать IP-пакеты, должен отвечать на ARP-запросы, чтобы другие узлы могли найти его в локальной сети по IP-адресу.

ARP работет следующим образом:

Узел, который хочет узнать MAC-адрес другого узла, посылает широковещательный запрос с IP-адресом искомого узла.
Узел с указанным IP-адресом отсылает ответ первому узлу.
Первый узел добавляет адрес найденного узла в ARP-кэш, затем время от времени посылает новые запросы, чтобы убедиться, что второй узел никуда не делся.

Пример кода:

#define ARP_HW_TYPE_ETH        htons(0x0001)
#define ARP_PROTO_TYPE_IP    htons(0x0800)

#define ARP_TYPE_REQUEST    htons(1)
#define ARP_TYPE_RESPONSE    htons(2)

// ARP-пакет
typedef struct arp_message {
    uint16_t hw_type; // протокол канального уровня (Ethernet)
    uint16_t proto_type; // протокол сетевого уровня (IP)
    uint8_t hw_addr_len; // длина MAC-адреса =6
    uint8_t proto_addr_len; // длина IP-адреса =4
    uint16_t type; // тип сообщения (запрос/ответ)
    uint8_t mac_addr_from[6]; // MAC-адрес отправителя
    uint32_t ip_addr_from; // IP-адрес отправителя
    uint8_t mac_addr_to[6]; // MAC-адрес получателя, нули если неизвестен
    uint32_t ip_addr_to; // IP-адрес получателя
} arp_message_t;

// Обработчик ARP-пакетов
void arp_filter(eth_frame_t *frame, uint16_t len)
{
    arp_message_t *msg = (void*)(frame->data);

    // Проверяем длину пакета
    if(len >= sizeof(arp_message_t))
    {
        // Проверяем тип протокола
        if( (msg->hw_type == ARP_HW_TYPE_ETH) &&
            (msg->proto_type == ARP_PROTO_TYPE_IP) )
        {
            // ARP-запрос и наш IP-адрес?
            if( (msg->type == ARP_TYPE_REQUEST) && 
                (msg->ip_addr_to == ip_addr) )
            {
                // Отправляем ответ
                msg->type = ARP_TYPE_RESPONSE;
                memcpy(msg->mac_addr_to, msg->mac_addr_from, 6);
                memcpy(msg->mac_addr_from, mac_addr, 6);
                msg->ip_addr_to = msg->ip_addr_from;
                msg->ip_addr_from = ip_addr;

                eth_reply(frame, sizeof(arp_message_t));
            }
        }
    }
}


IP

IP (Internet Protocol) — протокол сетевого уровня. А заодно и сердце наших интернетов. Служит он для абстрагирования от технологии локальной сети, для маршрутизации пакетов между сетями, etc.

Формат IP-пакета:

IP-пакет

Версия — 4 для IPv4.
Длина заголовка — 5 (dword'ов) для стандартного пакета.
Длина пакета — суммарная длина заголовка и поля данных. Важна, поскольку точный размер пакета мы не знаем из-за выравнивания Ethernet-фреймов.
Время жизни — это поле уменьшается после каждого хопа (прохождения пакета через роутер). Если оно доходит до нуля, пакет прибивается. Нужно для отлавливания «заблудившихся» пакетов. При отпраке пакета пишем в него, например, 64.
Принцип рассчёта контрольной суммы описан ниже, в примере кода. При рассчёте контрольной суммы заголовка в данном поле должен быть 0.

Для каждой локальной сети определён MTU (Maximum Transmission Unit) — максимальный размер пакета, который она может протащить через себя. Например, для Ethernet — 1500 байт, максимальный размер поля данных в фрейме. Если пакет переходит в сеть, через которую он не может пролезть целиком, IP фрагментирует пакет. В каждом фрагменте устанавливается идентификатор и смещение фрагмента. Это значит, что, теоретически, пакет может прийти нам по кусочкам.

Впрочем, минимально допустимый MTU для IP — 576 байт. Пакеты до такого размера фрагментироваться не будут. Если мы не собираемся посылать и принимать пакеты больше минимального MTU, на фрагментирование можно просто забить.

Пример кода:

// Коды протоколов
#define IP_PROTOCOL_ICMP    1
#define IP_PROTOCOL_TCP        6
#define IP_PROTOCOL_UDP        17

// IP-пакет
typedef struct ip_packet {
    uint8_t ver_head_len; // версия и длина заголовка =0x45
    uint8_t tos; //тип сервиса
    uint16_t total_len; //длина всего пакета
    uint16_t fragment_id; //идентификатор фрагмента
    uint16_t flags_framgent_offset; //смещение фрагмента
    uint8_t ttl; //TTL
    uint8_t protocol; //код протокола
    uint16_t cksum; //контрольная сумма заголовка
    uint32_t from_addr; //IP-адрес отправителя
    uint32_t to_addr; //IP-адрес получателя
    uint8_t data[];
} ip_packet_t;


// Отправка IP-пакета в ответ - для сервера
void ip_reply(eth_frame_t *frame, uint16_t len)
{
    ip_packet_t *packet = (void*)(frame->data);

    // Заполняем заголовок
    packet->total_len = htons(len + sizeof(ip_packet_t));
    packet->fragment_id = 0;
    packet->flags_framgent_offset = 0;
    packet->ttl = IP_PACKET_TTL;
    packet->cksum = 0;
    packet->to_addr = packet->from_addr;
    packet->from_addr = ip_addr;
    packet->cksum = ip_cksum(0, (void*)packet, sizeof(ip_packet_t));

    // Заворачиваем в Ethernet-фрейм и отправляем
    eth_reply((void*)frame, len + sizeof(ip_packet_t));
}

// Обработчик IP-пакетов
void ip_filter(eth_frame_t *frame, uint16_t len)
{
    ip_packet_t *packet = (void*)(frame->data);
    
    // Можно не проверять - минимальное поле данных Ethernet-фрейма
    //  всегда больше размера IP-заголовка
    //if(len >= sizeof(ip_packet_t))
    //{
        // Проверяем версию протокола и адрес получателя
        if( (packet->ver_head_len == 0x45) &&
            (packet->to_addr == ip_addr) )
        {
            // Вычисляем длину поля данных
            len = ntohs(packet->total_len) - 
                sizeof(ip_packet_t);

            switch(packet->protocol)
            {
            // Протокол = ICMP, вызываем обработчик пакетов
            case IP_PROTOCOL_ICMP:
                icmp_filter(frame, len);
                break;
            
            // Протокол = UDP, вызываем обработчик пакетов
            case IP_PROTOCOL_UDP:
                udp_filter(frame, len);
                break;
            }
        }
    //}
}

// Рассчёт контрольной суммы для IP (и других протоколов)
uint16_t ip_cksum(uint32_t sum, uint8_t *buf, size_t len)
{
    // Рассчитываем сумму word'ов блока (big endian)
    // (блок выравнивается на word нулём)
    while(len >= 2)
    {
        sum += ((uint16_t)*buf << 8) | *(buf+1);
        buf += 2;
        len -= 2;
    }

    if(len)
        sum += (uint16_t)*buf << 8;

    // Складываем старший и младший word суммы
    // пока не получим число, влезающее в word
    while(sum >> 16)
        sum = (sum & 0xffff) + (sum >> 16);

    // Снова конвертируем в big endian и берём дополнение
    return ~htons((uint16_t)sum);
}


ICMP

ICMP (Internet Control Message Protocol) — вспомогательный протокол сетевого уровня, работающий «рядом» с IP. ICMP служит, в том числе, и для диагностики сети. Всем известная утилита ping использует ICMP Echo-запросы. Если мы хотим, чтобы девайс пинговался, можно добавить поддержку ICMP Echo-запросов.

ICMP-сообщение заворачивается в IP-пакет. Echo-запрос и ответ выглядят вот так:

Ping-пакет

Тип пакета. Запрос (8) или ответ (0).
Код пакета — 0 для Echo-запроса и ответа.
Контрольная сумма заголовка рассчитыватся также, как и для заголовка IP-пакета.

Остальные поля устанавливаются на усмотрение хоста. Ответ должен содержать те же значения.

Пример кода:

// Тип пакета
#define ICMP_TYPE_ECHO_RQ    8
#define ICMP_TYPE_ECHO_RPLY    0

// ICMP Echo-пакет
typedef struct icmp_echo_packet {
    uint8_t type;
    uint8_t code;
    uint16_t cksum;
    uint16_t id;
    uint16_t seq;
    uint8_t data[];
} icmp_echo_packet_t;

// Обработчик ICMP-пакета
void icmp_filter(eth_frame_t *frame, uint16_t len)
{
    ip_packet_t *packet = (void*)frame->data;
    icmp_echo_packet_t *icmp = (void*)packet->data;

    // Проверяем длину пакета
    if(len >= sizeof(icmp_echo_packet_t) )
    {
        // Получили Echo-запрос
        if(icmp->type == ICMP_TYPE_ECHO_RQ)
        {
            // Меняем тип пакета на ответ
            icmp->type = ICMP_TYPE_ECHO_RPLY;
            
            // Обновляем контрольную сумму,
            // мы изменили только одно поле в пакете,
            // так что пересчитывать полностью не обязательно
            icmp->cksum += 8;
            
            // Отправляем пакет назад
            ip_reply(frame, len);
        }
    }
}


UDP

UDP (User Datagram Protocol) — простейший протокол транспортного уровня. UDP позволяет узлам обмениваться небольшими сообщениями, называемыми датаграммами.

Тут мы реализуем UDP-сервер — информация будет отправляться только в ответ на запрос.

Чтобы датаграмма точно пролезла в MTU сети без фрагментации IP-пакета, количество полезных данных в ней не должно превышать 512 байт.

UDP называется ненадёжным протоколом — при потере IP-пакета, датаграмма теряется. Впрочем, современные сети вполне себе надёжны — в хорошо работающей локальной сети пакеты не теряются почти никогда. Но, естественно, приложение должно адекватно реагировать, если датаграмма всё же потеряется.

UDP отлично подходит для передачи данных в реальном времени, нечувствительных к потерям. Скажем, с помощью UDP удобно забирать показания каких-нибудь датчиков или отправлять инфомрацию на дисплей.

UDP-пакет заворачивается в IP-пакет. Формат UDP-пакета:

UDP-пакет

Контрольная сумма тут рассчитывается необычно. Не от самого пакета, а от пакета с псевдозаголовком, который выглядит вот так:

UDP-пакет с псевдозаголовком

Часть полей берётся из заголовка IP-пакета (который, кстати, и сам с контрольной суммой). Мда)

Рассчитаная от этой штуки контрольная сумма записывается уже в нормальный UDP-пакет.

Пример кода:

// UDP-пакет
typedef struct udp_packet {
    uint16_t from_port;
    uint16_t to_port;
    uint16_t len;
    uint16_t cksum;
    uint8_t data[];
} udp_packet_t;

// Обработчик UDP-пакета
void udp_filter(eth_frame_t *frame, uint16_t len)
{
    ip_packet_t *ip = (void*)(frame->data);
    udp_packet_t *udp = (void*)(ip->data);

    // Проверяем длину заголовка
    if(len >= sizeof(udp_packet_t))
    {
        // Отдаём пакет приложению
        udp_packet(frame, ntohs(udp->len) - 
            sizeof(udp_packet_t));
    }
}

// Ответ на UDP-пакет
void udp_reply(eth_frame_t *frame, uint16_t len)
{
    ip_packet_t *ip = (void*)(frame->data);
    udp_packet_t *udp = (void*)(ip->data);
    uint16_t temp;

    // Рассчитываем длину всего пакета
    len += sizeof(udp_packet_t);

    // Меняем местами порт отправителя и получателя
    temp = udp->from_port;
    udp->from_port = udp->to_port;
    udp->to_port = temp;

    // Длина пакета
    udp->len = htons(len);

    // Рассчитываем контрольную сумму от псведозаголовка + данных
    // Псведозаголовок = длина пакета+протокол+IP адреса+нормальный udp-заголовок
    // длину пакета+протокол передаём как начальное значение для 
    // рассчёта контрольной суммы
    // ip адреса берём из заголовка IP-пакета (udp-пакет - 8)
    udp->cksum = 0;
    udp->cksum = ip_cksum(len + IP_PROTOCOL_UDP, 
        (uint8_t*)udp-8, len+8);

    ip_reply(frame, len);
}


Приложение

Чтобы придать всему этому смысл, напишем простенькое приложение, работающее по UDP. Например, «переходник» Ethernet-UART.

// Цепляем библиотеку для буферизованной работы с UART
#include "buart.h"

// При приёме UDP-пакета
void udp_packet(eth_frame_t *frame, uint16_t len)
{
    ip_packet_t *ip = (void*)(frame->data);Краткое содержание:

Полезные штуки
Стек протоколов
Протокол Ethernet
ARP
IP
ICMP
UDP
Пишем приложение
Заключение

Что пригодится

При написании сетевых приложений для МК накосячить просто, а найти баг — не всегда. Так что, есть смысл для отладки использовать различные прикольные штуки, отладку общегчающие:

JTAG-адаптер для AVR'ок — поможет заглянуть в память и регистры МК, потрейсить прошивку. Поддерживается AVR Studio 4. Жутко тормозной, но найти многие баги с ним всё же намного быстрее, чем без него.
Wireshark — хороший кроссплатформенный сниффер. Покажет данные, передаваемые через сетевой адаптер компа. Умеет анализировать протоколы. Покажет в каком месте пакета что-то не так (битая чексумма, неверная длина пакета, etc.). Настраивается методом научного тыка)
netcat — удобная утилитка, которая поможет отправлять и принимать данные по сети. Под Windows можно взять нативную сборку, либо установить из cygwin'а.

Стек протоколов

Вот так будет выглядеть стек протоколов, который мы реализуем:

Стек протоколов

При прохождении пакета вниз по стеку, к нему прикрепляются заголовки протоколов. Например, вот так будет выглядеть UDP-пакет при передаче по сети Ethernet.

Пример пакета

В соответствии с моделью OSI, уровни должны быть изолированы друг от друга. Но у нас будет не совсем так, все протоколы будут работать с одним и тем же пакетом, но обращаться к своим заголовкам. Что позволит сэкономить память и такты микроконтроллера. Для такого простого стека это вполне нормально.

Неприятная особенность IP-стека — все поля пакетов всех протоколов закодированы в этом чудовищном атавизме, big endian'е. Придётся перекодировать в нормальный формат и обратно. Для этого пригодятся макросы:

// Перекодирование word'а
#define htons(a)            ((((a)>>8)&0xff)|(((a)<<8)&0xff00))
#define ntohs(a)            htons(a)

// Перекодирование dword'а
#define htonl(a)            ( (((a)>>24)&0xff) | (((a)>>8)&0xff00) |\
                                (((a)<<8)&0xff0000) | (((a)<<24)&0xff000000) )
#define ntohl(a)            htonl(a)


Для работы стека, устройству нужно задать MAC-адрес и IP-адрес.

// Макрос для IP-адреса
#define inet_addr(a,b,c,d)    ( ((uint32_t)a) | ((uint32_t)b << 8) |\
                                ((uint32_t)c << 16) | ((uint32_t)d << 24) )

// MAC-адрес
uint8_t mac_addr[6] = {0x00,0x13,0x37,0x01,0x23,0x45};

// IP-адрес
uint32_t ip_addr = inet_addr(192,168,0,222);



Ethernet

Вот формат Ethernet-фрейма:

Ethernet-фрейм

Контрольная сумма рассчитывается и проверяется ENC28J60, так что для нас остяются видимы только 4 поля:

Адрес получателя. Тут может находиться конкретный MAC-адрес, широковещательный адрес ff:ff:ff:ff:ff:ff или Multicast-адрес. В Multicast-адресе установлен бит 40 (01:00:00:00:00:00). Обрати на это внимание. Если ты установишь своему девайсу адрес, например, 01:23:45:67:89:ab, получишь кучу проблем, источник которых вовсе не очевиден. Когда будешь придумывать MAC-адрес, лучше вообще обнули старший байт.
Адрес отправителя. Тут MAC-адрес, с которого отправлен фрейм.
По стандарту, здесь может находиться длина поля данных фрейма (без выравнивания), либо идентификатор протокола. Если бит 8 (0x0800) установлен, поле идентифицирует протокол. В случае протоколов IP-стека (IP, ARP, etc.), здесь находится именно идентификатор протокола и ничего другого.
Поле данных. Здесь будет полезная нагрузка, например, IP-пакет. В нормальном фрейме данных должно быть от 60 до 1500 байт. Если реальных данных меньше, поле выравнивается нулями до 60 байт.

Вот пример работы с Ethernet-фреймом:

#define ETH_TYPE_ARP        htons(0x0806)
#define ETH_TYPE_IP            htons(0x0800)

// Ethernet-фрейм
typedef struct eth_frame {
    uint8_t to_addr[6]; // адрес получателя
    uint8_t from_addr[6]; // адрес отправителя
    uint16_t type; // протокол
    uint8_t data[];
} eth_frame_t;

// Отправка ответа на Ethernet-фрейм
//  (подходит для серверного приложения -
//  получили запрос, обменяли местами адрес отправителя и получателя,
//  отправили назад)
void eth_reply(eth_frame_t *frame, uint16_t len)
{
    memcpy(frame->to_addr, frame->from_addr, 6);
    memcpy(frame->from_addr, mac_addr, 6);
    enc28j60_send_packet((void*)frame, len + 
        sizeof(eth_frame_t));
}

// Обработчик получаемых Ethernet-фреймов
void eth_filter(eth_frame_t *frame, uint16_t len)
{
    // Проверяем длину фрейма
    // Проверять адрес получателя не будем,
    //  положимся на фильтр пакетов ENC28J60
    if(len >= sizeof(eth_frame_t))
    {
        switch(frame->type)
        {
        // Получен ARP-пакет, вызываем обработчик ARP-пакетов
        case ETH_TYPE_ARP:
            arp_filter(frame, len - sizeof(eth_frame_t));
            break;
        
        // Получен IP-пакет, вызываем обработчик IP-пакетов
        case ETH_TYPE_IP:
            ip_filter(frame, len - sizeof(eth_frame_t));
            break;
        }
    }
}


ARP

ARP (Address Resolution Protocol) — вспомогательный протокол, позволяющий получить MAC-адрес узла по IP-адресу.

Узел, желающий получать IP-пакеты, должен отвечать на ARP-запросы, чтобы другие узлы могли найти его в локальной сети по IP-адресу.

ARP работет следующим образом:

Узел, который хочет узнать MAC-адрес другого узла, посылает широковещательный запрос с IP-адресом искомого узла.
Узел с указанным IP-адресом отсылает ответ первому узлу.
Первый узел добавляет адрес найденного узла в ARP-кэш, затем время от времени посылает новые запросы, чтобы убедиться, что второй узел никуда не делся.

Пример кода:

#define ARP_HW_TYPE_ETH        htons(0x0001)
#define ARP_PROTO_TYPE_IP    htons(0x0800)

#define ARP_TYPE_REQUEST    htons(1)
#define ARP_TYPE_RESPONSE    htons(2)

// ARP-пакет
typedef struct arp_message {
    uint16_t hw_type; // протокол канального уровня (Ethernet)
    uint16_t proto_type; // протокол сетевого уровня (IP)
    uint8_t hw_addr_len; // длина MAC-адреса =6
    uint8_t proto_addr_len; // длина IP-адреса =4
    uint16_t type; // тип сообщения (запрос/ответ)
    uint8_t mac_addr_from[6]; // MAC-адрес отправителя
    uint32_t ip_addr_from; // IP-адрес отправителя
    uint8_t mac_addr_to[6]; // MAC-адрес получателя, нули если неизвестен
    uint32_t ip_addr_to; // IP-адрес получателя
} arp_message_t;

// Обработчик ARP-пакетов
void arp_filter(eth_frame_t *frame, uint16_t len)
{
    arp_message_t *msg = (void*)(frame->data);

    // Проверяем длину пакета
    if(len >= sizeof(arp_message_t))
    {
        // Проверяем тип протокола
        if( (msg->hw_type == ARP_HW_TYPE_ETH) &&
            (msg->proto_type == ARP_PROTO_TYPE_IP) )
        {
            // ARP-запрос и наш IP-адрес?
            if( (msg->type == ARP_TYPE_REQUEST) && 
                (msg->ip_addr_to == ip_addr) )
            {
                // Отправляем ответ
                msg->type = ARP_TYPE_RESPONSE;
                memcpy(msg->mac_addr_to, msg->mac_addr_from, 6);
                memcpy(msg->mac_addr_from, mac_addr, 6);
                msg->ip_addr_to = msg->ip_addr_from;
                msg->ip_addr_from = ip_addr;

                eth_reply(frame, sizeof(arp_message_t));
            }
        }
    }
}


IP

IP (Internet Protocol) — протокол сетевого уровня. А заодно и сердце наших интернетов. Служит он для абстрагирования от технологии локальной сети, для маршрутизации пакетов между сетями, etc.

Формат IP-пакета:

IP-пакет

Версия — 4 для IPv4.
Длина заголовка — 5 (dword'ов) для стандартного пакета.
Длина пакета — суммарная длина заголовка и поля данных. Важна, поскольку точный размер пакета мы не знаем из-за выравнивания Ethernet-фреймов.
Время жизни — это поле уменьшается после каждого хопа (прохождения пакета через роутер). Если оно доходит до нуля, пакет прибивается. Нужно для отлавливания «заблудившихся» пакетов. При отпраке пакета пишем в него, например, 64.
Принцип рассчёта контрольной суммы описан ниже, в примере кода. При рассчёте контрольной суммы заголовка в данном поле должен быть 0.

Для каждой локальной сети определён MTU (Maximum Transmission Unit) — максимальный размер пакета, который она может протащить через себя. Например, для Ethernet — 1500 байт, максимальный размер поля данных в фрейме. Если пакет переходит в сеть, через которую он не может пролезть целиком, IP фрагментирует пакет. В каждом фрагменте устанавливается идентификатор и смещение фрагмента. Это значит, что, теоретически, пакет может прийти нам по кусочкам.

Впрочем, минимально допустимый MTU для IP — 576 байт. Пакеты до такого размера фрагментироваться не будут. Если мы не собираемся посылать и принимать пакеты больше минимального MTU, на фрагментирование можно просто забить.

Пример кода:

// Коды протоколов
#define IP_PROTOCOL_ICMP    1
#define IP_PROTOCOL_TCP        6
#define IP_PROTOCOL_UDP        17

// IP-пакет
typedef struct ip_packet {
    uint8_t ver_head_len; // версия и длина заголовка =0x45
    uint8_t tos; //тип сервиса
    uint16_t total_len; //длина всего пакета
    uint16_t fragment_id; //идентификатор фрагмента
    uint16_t flags_framgent_offset; //смещение фрагмента
    uint8_t ttl; //TTL
    uint8_t protocol; //код протокола
    uint16_t cksum; //контрольная сумма заголовка
    uint32_t from_addr; //IP-адрес отправителя
    uint32_t to_addr; //IP-адрес получателя
    uint8_t data[];
} ip_packet_t;


// Отправка IP-пакета в ответ - для сервера
void ip_reply(eth_frame_t *frame, uint16_t len)
{
    ip_packet_t *packet = (void*)(frame->data);

    // Заполняем заголовок
    packet->total_len = htons(len + sizeof(ip_packet_t));
    packet->fragment_id = 0;
    packet->flags_framgent_offset = 0;
    packet->ttl = IP_PACKET_TTL;
    packet->cksum = 0;
    packet->to_addr = packet->from_addr;
    packet->from_addr = ip_addr;
    packet->cksum = ip_cksum(0, (void*)packet, sizeof(ip_packet_t));

    // Заворачиваем в Ethernet-фрейм и отправляем
    eth_reply((void*)frame, len + sizeof(ip_packet_t));
}

// Обработчик IP-пакетов
void ip_filter(eth_frame_t *frame, uint16_t len)
{
    ip_packet_t *packet = (void*)(frame->data);
    
    // Можно не проверять - минимальное поле данных Ethernet-фрейма
    //  всегда больше размера IP-заголовка
    //if(len >= sizeof(ip_packet_t))
    //{
        // Проверяем версию протокола и адрес получателя
        if( (packet->ver_head_len == 0x45) &&
            (packet->to_addr == ip_addr) )
        {
            // Вычисляем длину поля данных
            len = ntohs(packet->total_len) - 
                sizeof(ip_packet_t);

            switch(packet->protocol)
            {
            // Протокол = ICMP, вызываем обработчик пакетов
            case IP_PROTOCOL_ICMP:
                icmp_filter(frame, len);
                break;
            
            // Протокол = UDP, вызываем обработчик пакетов
            case IP_PROTOCOL_UDP:
                udp_filter(frame, len);
                break;
            }
        }
    //}
}

// Рассчёт контрольной суммы для IP (и других протоколов)
uint16_t ip_cksum(uint32_t sum, uint8_t *buf, size_t len)
{
    // Рассчитываем сумму word'ов блока (big endian)
    // (блок выравнивается на word нулём)
    while(len >= 2)
    {
        sum += ((uint16_t)*buf << 8) | *(buf+1);
        buf += 2;
        len -= 2;
    }

    if(len)
        sum += (uint16_t)*buf << 8;

    // Складываем старший и младший word суммы
    // пока не получим число, влезающее в word
    while(sum >> 16)
        sum = (sum & 0xffff) + (sum >> 16);

    // Снова конвертируем в big endian и берём дополнение
    return ~htons((uint16_t)sum);
}


ICMP

ICMP (Internet Control Message Protocol) — вспомогательный протокол сетевого уровня, работающий «рядом» с IP. ICMP служит, в том числе, и для диагностики сети. Всем известная утилита ping использует ICMP Echo-запросы. Если мы хотим, чтобы девайс пинговался, можно добавить поддержку ICMP Echo-запросов.

ICMP-сообщение заворачивается в IP-пакет. Echo-запрос и ответ выглядят вот так:

Ping-пакет

Тип пакета. Запрос (8) или ответ (0).
Код пакета — 0 для Echo-запроса и ответа.
Контрольная сумма заголовка рассчитыватся также, как и для заголовка IP-пакета.

Остальные поля устанавливаются на усмотрение хоста. Ответ должен содержать те же значения.

Пример кода:

// Тип пакета
#define ICMP_TYPE_ECHO_RQ    8
#define ICMP_TYPE_ECHO_RPLY    0

// ICMP Echo-пакет
typedef struct icmp_echo_packet {
    uint8_t type;
    uint8_t code;
    uint16_t cksum;
    uint16_t id;
    uint16_t seq;
    uint8_t data[];
} icmp_echo_packet_t;

// Обработчик ICMP-пакета
void icmp_filter(eth_frame_t *frame, uint16_t len)
{
    ip_packet_t *packet = (void*)frame->data;
    icmp_echo_packet_t *icmp = (void*)packet->data;

    // Проверяем длину пакета
    if(len >= sizeof(icmp_echo_packet_t) )
    {
        // Получили Echo-запрос
        if(icmp->type == ICMP_TYPE_ECHO_RQ)
        {
            // Меняем тип пакета на ответ
            icmp->type = ICMP_TYPE_ECHO_RPLY;
            
            // Обновляем контрольную сумму,
            // мы изменили только одно поле в пакете,
            // так что пересчитывать полностью не обязательно
            icmp->cksum += 8;
            
            // Отправляем пакет назад
            ip_reply(frame, len);
        }
    }
}


UDP

UDP (User Datagram Protocol) — простейший протокол транспортного уровня. UDP позволяет узлам обмениваться небольшими сообщениями, называемыми датаграммами.

Тут мы реализуем UDP-сервер — информация будет отправляться только в ответ на запрос.

Чтобы датаграмма точно пролезла в MTU сети без фрагментации IP-пакета, количество полезных данных в ней не должно превышать 512 байт.

UDP называется ненадёжным протоколом — при потере IP-пакета, датаграмма теряется. Впрочем, современные сети вполне себе надёжны — в хорошо работающей локальной сети пакеты не теряются почти никогда. Но, естественно, приложение должно адекватно реагировать, если датаграмма всё же потеряется.

UDP отлично подходит для передачи данных в реальном времени, нечувствительных к потерям. Скажем, с помощью UDP удобно забирать показания каких-нибудь датчиков или отправлять инфомрацию на дисплей.

UDP-пакет заворачивается в IP-пакет. Формат UDP-пакета:

UDP-пакет

Контрольная сумма тут рассчитывается необычно. Не от самого пакета, а от пакета с псевдозаголовком, который выглядит вот так:

UDP-пакет с псевдозаголовком

Часть полей берётся из заголовка IP-пакета (который, кстати, и сам с контрольной суммой). Мда)

Рассчитаная от этой штуки контрольная сумма записывается уже в нормальный UDP-пакет.

Пример кода:

// UDP-пакет
typedef struct udp_packet {
    uint16_t from_port;
    uint16_t to_port;
    uint16_t len;
    uint16_t cksum;
    uint8_t data[];
} udp_packet_t;

// Обработчик UDP-пакета
void udp_filter(eth_frame_t *frame, uint16_t len)
{
    ip_packet_t *ip = (void*)(frame->data);
    udp_packet_t *udp = (void*)(ip->data);

    // Проверяем длину заголовка
    if(len >= sizeof(udp_packet_t))
    {
        // Отдаём пакет приложению
        udp_packet(frame, ntohs(udp->len) - 
            sizeof(udp_packet_t));
    }
}

// Ответ на UDP-пакет
void udp_reply(eth_frame_t *frame, uint16_t len)
{
    ip_packet_t *ip = (void*)(frame->data);
    udp_packet_t *udp = (void*)(ip->data);
    uint16_t temp;

    // Рассчитываем длину всего пакета
    len += sizeof(udp_packet_t);

    // Меняем местами порт отправителя и получателя
    temp = udp->from_port;
    udp->from_port = udp->to_port;
    udp->to_port = temp;

    // Длина пакета
    udp->len = htons(len);

    // Рассчитываем контрольную сумму от псведозаголовка + данных
    // Псведозаголовок = длина пакета+протокол+IP адреса+нормальный udp-заголовок
    // длину пакета+протокол передаём как начальное значение для 
    // рассчёта контрольной суммы
    // ip адреса берём из заголовка IP-пакета (udp-пакет - 8)
    udp->cksum = 0;
    udp->cksum = ip_cksum(len + IP_PROTOCOL_UDP, 
        (uint8_t*)udp-8, len+8);

    ip_reply(frame, len);
}


Приложение

Чтобы придать всему этому смысл, напишем простенькое приложение, работающее по UDP. Например, «переходник» Ethernet-UART.

// Цепляем библиотеку для буферизованной работы с UART
#include "buart.h"

// При приёме UDP-пакета
void udp_packet(eth_frame_t *frame, uint16_t len)
{
    ip_packet_t *ip = (void*)(frame->data);
    udp_packet_t *udp = (void*)(ip->data);
    uint8_t *data = udp->data;
    uint8_t i, count;

    // Отпавляем данные в UART
    for(i = 0; i < len; ++i)
        uart_write(data[i]);

    // Возвращаем компу то, что наприходило 
    //  с момента последнего обмена
    count = uart_rx_count();
    if(count)
    {
        for(i = 0; i < count; ++i)
            data[i] = uart_read();
        udp_reply(frame, count);
    }
}

int main()
{
    uint8_t len;
    static uint8_t net_buf[576];
    eth_frame_t *frame = (void*)net_buf;

    // Инициализируем ENC28J60
    enc28j60_init(mac_addr);
    
    // Инициализируем UART
    uart_init();
    sei();

    // Ловим приходящие пакеты
    while(1)
    {
        if((len = enc28j60_recv_packet(net_buf, sizeof(net_buf))))
            eth_filter(frame, len);
    }

    return 0;
}


Работать с переходником просто. Чтобы вывести данные в UART, отправляем девайсу UDP-пакет на любой порт. Если с момента последнего обмена на UART приходили данные, девайс возвращает пакет с этими данными. Чтобы постоянно получать данные, комп должен с некоторым интервалом посылать девайсу пакеты (хотя бы пустые). В принципе, типичный способ общения с сервером.
    udp_packet_t *udp = (void*)(ip->data);
    uint8_t *data = udp->data;
    uint8_t i, count;

    // Отпавляем данные в UART
    for(i = 0; i < len; ++i)
        uart_write(data[i]);

    // Возвращаем компу то, что наприходило 
    //  с момента последнего обмена
    count = uart_rx_count();
    if(count)
    {
        for(i = 0; i < count; ++i)
            data[i] = uart_read();
        udp_reply(frame, count);
    }
}

int main()
{
    uint8_t len;
    static uint8_t net_buf[576];
    eth_frame_t *frame = (void*)net_buf;

    // Инициализируем ENC28J60
    enc28j60_init(mac_addr);
    
    // Инициализируем UART
    uart_init();
    sei();

    // Ловим приходящие пакеты
    while(1)
    {
        if((len = enc28j60_recv_packet(net_buf, sizeof(net_buf))))
            eth_filter(frame, len);
    }

    return 0;
}


Работать с переходником просто. Чтобы вывести данные в UART, отправляем девайсу UDP-пакет на любой порт. Если с момента последнего обмена на UART приходили данные, девайс возвращает пакет с этими данными. Чтобы постоянно получать данные, комп должен с некоторым интервалом посылать девайсу пакеты (хотя бы пустые). В принципе, типичный способ общения с сервером.